Program = { Statement } ;

Statement = 
      VarDeclStmt
    | BlockStmt
    | ModuleDeclStmt
    | ImportStmt
    | FnDeclStmt
    | ReturnStmt
    | TypeDeclStmt
    | CtorDeclStmt
    | DtorDeclStmt
    | EnumMemberDeclStmt
    | AssignmentStmt
    | IfStmt
    | MatchStmt
    | WhileStmt
    | ForStmt 
    | ContinueStmt
    | BreakStmt
    | ThrowStmt
    | TryCatchStmt
    , [ ';' ] ;

Expression =
      Literal
    | Name
    | ParenthesesExpr
    | FnExpr
    | MatchExpr
    | UnaryExpr
    | BinaryExpr
    | TernaryExpr
    | SubscriptExpr
    | CastExpr
    | CallExpr
    | RangeExpr
    | TryElseExpr ;

(* Variable Declaration Statement *)
VarDeclStmt = [ Annotation ] , ( 'let' | 'const' | 'ref' | 'cref' ) , [ '^' ] , Identifier , [ ':' , Name ] , '=' , Expression ;

(* Block Statement *)
BlockStmt = 'do' , { Statement } , 'end' ;

(* Module Declaration Statement *)
ModuleDeclStmt = [ Annotation ] , 'module' , Identifier , { '.' , Identifier } , BlockStmt ;

(* Import Statement *)
ImportStmt = 'from' , Name , 'import' , ImportedName , { ',' , ImportedName } ;
ImportedName = Name , [ 'as' , Identifier ];

(* Function *)
FnDeclStmt = [ Annotation ] , 'fn' , [ '^' ] , Identifier , FnBody ;
FnExpr = [ Annotation ] , 'fn' , [ '^' ] , FnBody ;
FnBody = '(' , [ FnParameter , { ',' , FnParameter } ] ,  ')' , 
         [ '['  , [ FnCapturedValue , { ',' , FnCapturedValue } ] , ']' ] , 
         [ '->' , Name ] , 
         BlockStmt ;
FnParameter = [ 'let' | 'const' ] , ( Identifier | Discard ) , ':' , Name , [ '=' , Expression ] ;
FnCapturedValue = [ 'let' | 'const' ] , Name ;

(* Return Statement *)
ReturnStmt = 'return' , [ Expression ] ;

(* Type Declaration Statement *)
TypeDeclStmt = [ Annotation ] , ( 'class' | 'struct' | 'trait' | 'alias' | 'extension' ) , SingleName , [ '^' ] ,
               [ ':' , Name , { ',' , Name } ] , BlockStmt ;

(* Constructor/Destructor Statements *)
CtorDeclStmt = [ Annotation ] , 'constructor' , FnBody ;
DtorDeclStmt = [ Annotation ] , 'destructor' , FnBody ;

(* Enum Member Declaration Statement *)
EnumMemberDeclStmt = [ Annotation ] , 'case' , Identifier , [ '(' , Identifier , ':' , Name , ')' ] ;

(* Assignment Statement *)
AssignmentStmt = Name , AssignmentOp , Expression;

(* If Statement *)
IfStmt = 'if' , Expression , BlockStmt ,
         [ { 'else' , 'if' , Expression , BlockStmt } ] ,
         [ 'else' , BlockStmt ];

(* Match *)
MatchStmt = 'match' , Expression , [ 'as' , Identifier ] ,
            [ { 'case' , ( [ 'if' , Expression ] | ( Expression | Discard ) ) , BlockStmt } ] ,
            'end' ;
MatchExpr = 'match' , Expression , [ 'as' , Identifier ] ,
            [ { 'case' , ( [ 'if' , Expression ] | ( Expression | Discard ) ) , '=>' , ( Expression | ThrowStmt ) } ] ,
            'end' ;

(* While Statement *)
WhileStmt = 'while' , Expression , BlockStmt ;

(* For Statement *)
ForStmt = 'for' , Identifier , 'in' , Expression , BlockStmt ;

(* Continue/Break Statement *)
ContinueStmt = 'continue' ;
BreakStmt = 'break' ;

(* Throw Statement *)
ThrowStmt = 'throw' , [ Expression ] ;

(* Try/Catch Statement *)
TryCatchStmt = 'try' , BlockStmt , CatchBlock , { CatchBlock } ;
CatchBlock = 'catch' , ( ( Name , 'as' , ( Identifier | Discard ) ) | Discard ) , BlockStmt ;

(* Parentheses Expression *)
ParenthesesExpr = '(' , Expression , ')' ;

(* Unary Expression *)
UnaryExpr = UnaryOp , Expression ;

(* Binary Expression *)
BinaryExpr = Expression , BinaryExpr , Expression ;

(* Ternary Expression *)
TernaryExpr = Expression , '?' , Expression , ':' , Expression ;

(* Subscript Expression *)
SubscriptExpr = Expression , '[' , Expression , ']' ;

(* Cast Expression *)
CastExpr = '(' , Expression , ')' , Expression ;

(* Call Expression *)
CallExpr = Expression , '(' , [ Expression , { ',' , Expression } ] , ')' ;

(* Range Expression *)
RangeExpr = Expression , '..' , ( '.' | '<' | '>' ) , Expression , [ ':' , Expression ] ;

(* Try/Else Expression *)
TryElseExpr = 'try' , Expression , 'else' , ( Expression | ThrowStmt ) ;

(* Annotation *)
Annotation = '@' , Name , { ',' , Annotation  }

(* Identifier *)
Identifier = ( ( Letter | '_' ) , { Letter | Digit | '_' } ) - '_' ;
Discard = '_' ;

(* Literals *)
Literal = 
      IntegerLiteral
    | BooleanLiteral
    | StringLiteral
    | CollectionLiteral ;
IntegerLiteral = BinIntegerLiteral | DecIntegerLiteral | HexIntegerLiteral ;
BinIntegerLiteral = '0b' , BinDigit , { BinDigit } ;
DecIntegerLiteral = Digit , { Digit } ;
HexIntegerLiteral = '0x' , HexDigit , { HexDigit } ;
BooleanLiteral = 'true' | 'false' ;
StringLiteral = ( "'" , { StringCharacter } , "'") | ( '"' , { StringCharacter } , '"' ) ;
StringCharacter = ? any character except quote, backslash, and line break ? ;
CollectionLiteral = '{' , [ Expression ] , { ',' , Expression } , '}' ;

(* Name *)
Name = { '$' } , SingleName , { '.' , SingleName } ;
SingleName = Identifier , [ '<' , Name , { ',' , Name } , '>' ] , [ '^' ] ;

(* Misc *)
Letter = UpperCaseLetter | LowerCaseLetter ;
UpperCaseLetter = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
LowerCaseLetter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
BinDigit = '0' | '1' ;
Digit = BinDigit | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
HexDigit = Digit | 'A' | 'a' | 'B' | 'b' | 'C' | 'c' | 'D' | 'd' | 'E' | 'e' | 'F' | 'f' ;

(* Operators *)
UnaryOp = '+' | '-' | '!' | '~' ;
BinaryOp = '+' | '-' | '*' | '/' | '%' | '==' | '!=' | '>' | '<' | '>=' | '<=' | '&&' | '||' | '&' | '|' | '^' | '<<' | '>>' |  ;
AssignmentOp = [ '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^' | '<<' | '>>' ] , '=' ;
